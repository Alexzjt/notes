# 链表

#### 判断回文链表

1. 放入栈，比对弹出顺序和原顺序
2. 快慢指针判断链表中间点，但根据实际情况需要定制。翻转链表的后半部分，然后将中间值指向null，然后依次比对。注意恢复原状

#### 将单链表按某值划分成为左边小、中间相等、右边大的形式，相对顺序保持不变

6个变量：SH小头、ST小尾、EH相同头、ET相同尾、BH大头、BT大尾

遍历链表，将值放入相应位置并串联，再串联起ST->EH  ET->BH。注意空值情况

#### 克隆含有随机指针节点的链表

先克隆节点，先不考虑随机指针，将克隆节点串在原节点后面。例如

A->a->B->b-C->c->D-d->null

A的随机指针R，得到a的随机指针r。依次类推

将abcd从原有链表中提出，形成新链表

#### 判断是否有环

快慢指针，快指针一次走两步，慢指针一次走一步，能相遇就是有环

#### 判断是否有环并返回环的第一个节点（神奇的结论）

快慢指针相遇后，快指针=Head，慢指针在原地，两个节点都每次走一步。相遇就是第一个节点

#### 两个可能有环也可能无环的单链表（head1，head2），返回相交的第一个节点，不相交返回null

1. 先调用**判断是否有环并返回环的第一个节点（神奇的结论）**，返回loop1和loop2
   1. 如果loop1==loop2==null，说明都无环。先遍历两个链表，找出尾结点end1和end2，并记录长度length1和length2
      1. 如果end1和end2不相等则不相交
      2. 如果相等，则判断length1和length2。再遍历，长链表从头先走，走|length1-length2|（差值）步，然后短链表从头再走。相遇则return第一个节点
   2. 如果一个有环，一个无环。则不可能相交。直接return null
   3. 如果都有环。即loop1!=null && loop2!=null
      1. 如果loop1==loop2，说明入环节点相同。做法类似无环的做法。无视环的部分即可
      2. 如果不等。有两种可能，第一种两个平行，第二个两个共用环但入环节点不同。判断方法是：让loop1继续走
         1. 如果遇到自己则平行。return null
         2. 如果中途遇到loop2则共用环，return loop1或loop2都可以