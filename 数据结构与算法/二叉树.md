# 二叉树

递归序：每个节点会被遍历三次

先序，节点被第一次遍历时打印。中序，第二次打印。后序，第三次打印。

#### 非递归先序遍历

1. 准备一个栈，压栈根节点
2. 弹出一个节点current，打印或处理current
3. 如果有，则先压栈右孩子，再压栈左孩子
4. 重复2和3

#### 非递归中序遍历

1.  准备一个栈，压栈根节点
2. 连续的将每颗子树压栈
3. 出栈并打印，如果有右孩子则入栈
4. 重复2和3

#### 非递归后序遍历

1. 准备2个栈，压栈根节点
2. 弹出一个节点current，放入2号栈
3. 先压左孩子，再压右孩子
4. 重复2和3
5. 2号栈的出栈顺序就是后序遍历

因为1号栈的顺序是 【根右左】，所以出栈顺序是【左右根】

#### 判断搜索二叉树

1. 中序遍历，如果是升序，则搜索二叉树。
2. 递归做法。
   1. 左树是搜索二叉树
   2. 右树是搜索二叉树
   3. 左max < 当前value
   4. 右min > 当前value  

#### 判断完全二叉树

广度优先遍历。

1. 任意节点有右孩子没有左孩子，则return false
2. 如果不违反1，并且左右不双全，则后续必须都是叶子节点

#### 判断满二叉树

1. 先求最大深度d，再统计节点数N。 
   $$
   N=2^d-1
   $$

#### 判断平衡二叉树

左子树平衡、右子树平衡、左右高度差<=1

递归的从左树右树取{高度、是否平衡}

#### 二叉树题目套路（递归套路）（树型DP）

考虑从左树要什么信息，从右树要什么信息，然后定义某个类。

#### 最低公共祖先（二叉树两个节点node1和node2）

有两种情况

1. node1是node2的祖先，直接返回node1 （或者node2是node1的祖先）
2. 其他节点是node1和node2的祖先

```javascript
function lca(root, node1, node2) {
    if (!root || root===node1 || root===node2)
        return root;
    const leftLca = lca(root.left, node1, node2);
    const rightLca = lca(root.left, node1, node2);
    if (leftLca && rightLca)
        return root;
    return leftLca ? leftLca : rightLca;
}
```

#### 后继节点（指中序遍历顺序的下一个节点）有parent指针的情况

先找右孩子的最左叶子

再找右父节点

没有返回null