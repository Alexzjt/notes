# 有序表 O(lgN)

链表：SkipList跳表

平衡搜索二叉树：红黑树、AVL数（最平衡）、SB树（Size balanced tree）

二叉树 -> 搜索二叉树 -> 支持左旋、右旋 -> 平衡搜索二叉树（主要区别在于有多平衡？何时调用左右旋）

#### 搜索二叉树的删除节点

记录被删节点为D

如果D没有子树，直接删D

如果D左右子树只有一个，则将子树挂在父节点上，删除D

如果D左右双全，则从左子树的最右节点，或右子树的最左节点提取元素替换D

## 左旋右旋

主要看头节点倒向哪边。通过左旋右旋，二叉树可以更平衡

#### AVL树何时检查自己是不是平衡？

每次添加删除节点时，从修改的节点向上检查平衡性，如果不平衡就左旋右旋。

如果是删除时左右双全，则从被删节点的原父节点检查

LL型：左树的左边过长

RR型：右树的右边过长

LR型：左树的右边过长。让左孩子的右孩子成为整棵树的头部

RL型：右树的左边过长

#### 如何判断当前是上述哪种？

主要看左子树和有字数的高度差，分类

#### SB树（Size balanced tree）

每棵子树的大小，不小于其兄弟的子树大小

既每棵叔叔树的大小，不小于其任何侄子树的大小

#### 红黑树

1. 非红即黑
2. 叶节点指底层null节点。头和叶必须为黑
3. 红节点不相邻
4. cur出发，到叶节点的每一条路径的黑节点数一样

想保证的是，路径长度的倍数关系不会超过2倍。因为最长是红黑红黑交替，最短是全黑节点，要满足要求4。

#### 跳表

节点有 key value 指向后续节点的随机指针（随机个数）

有个无穷小的头节点。

每个节点添加时，随机roll一个数字作为本节点的随机指针个数。如果大于头节点的随机指针个数则头节点扩容。

从头指针的随机指针的最上面开始找，每次缩小[min, cur ,max]的min max范围。